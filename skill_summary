

1. initialize:  
# READING MULTIPLE CSV
#OMIT NA 
#data.frame 
#index
#names 
#download 

#download 
if (!file.exists("data")){
        dir.create("data")
}
fileurl <- "https:..."
download.file(fileurl, destfile = "./data/aa.csv", method = "curl", mode = "wb") #curl for Mac #mode for Error in .jcall("RJavaTools", "Ljava/lang/Object;", 
dateDownload <- data() 
 
url = "https://d396qusza40orc.cloudfront.net/rprog%2Fdata%2FProgAssignment3-data.zip"
download.file(url, destfile = "temp")
unzip("temp")
unlink("temp")

#initialize: read, index, name 

#read CSV as table
data <- read.table("data.csv", sep = ",", header T, rownames, quote ="", nrow, skip, na.strings)  #don't read quotation mark 
data <- fread("survey.csv, sep = ",")
# READING MULTIPLE CSV
data <- read.csv(paste(directory,"/","0",i,".csv",sep = ""), header = TRUE)
rates <- read.csv("outcome-of-care-measures.csv", colClasses = "character")


allData <- numeric()
comp <- data.frame(id=numeric(length(1:4)), nobs=numeric(length(1:4)))

#index
index <- c(grep("^Hospital.*Death*", names(rates)))  # ^ means the first letter, careful the capital 


#names 
names(mortality_rates)[3:5] <- c("heart attack", "heart failure", "pneumonia")

#OMIT NA 
mean(allData, na.rm=TRUE)
data2 <- na.omit(data) 
cor(a,b, use = "complete.obs")

#data.frame 
observedcase <- data.frame(id = numeric(length(id)), nobs= numeric(length(id)))
observedcase[["id"]][count] <- i
observedcase[["nobs"]][count] <- nobs
i in observations$id[observations$nobs > threshold]
#list 

l1 <- list(a = "a", b = 2, c = pi+2i)
unlist(l1)

  
  

2. simulation 
 sample(1:6, 4, replace = TRUE) #select 4 number from 1:6 
 flips <- sample(c(0,1), 100, replace = TRUE, prob = c(0.3, 0.7))

> rbinom (1, size = 100, prob = 0.7)
[1] 61              # a single random variable that represents the number of heads in 100 flips of our unfair coin
> flips2 <- rbinom(100, size = 1, prob = 0.7)
  [1] 1 1 1 1 0 0 1 0 1 1 1 0 0 1 1 1 0 0 1 0 1 1 1 0 1 1 1 1 0 0 0 1 0
 [34] 1 1 0 1 1 1 1 1 0 0 0 1 1 1 1 1 0 1 1 1 1 0 1 1 1 1 0 1 1 1 0 1 1
 [67] 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1 1 1 0 1 0 0 1 0 0 1 0 1 0 1 0 1 0 0
[100] 1

> rnorm(10, mean = 100, sd = 25)
 [1] 123.55667 107.49630  92.58885 111.22653 107.79632  74.79879
 [7]  99.03713  99.43503 118.14440  91.25727
#pnorm 
> pnorm(100, 50, lower.tail = F)
[1] 0
> pnorm(100,50)
[1] 1
> pnorm(50,50)
[1] 0.5




3.screening 
#which
which(state_data[,11] == min(state_data[,11],na.rm = T))      #return the number of row of min 
 
state_data <- outcame[outcame$State == state, ]

#subset 
aa <- data.frame(a = 1:5,c =c("a","b","c","d","e"), b =c(21,23,444,1,20))
bb <- subset.data.frame(aa, select = c (a,b))

complete1_subset <- subset(complete1, nobs > threshold)
 
 
 
 
4. order 
#order 
aa <- data.frame(a = 1:5,c =c("a","b","c","d","e"), b =c(21,23,444,1,20))
bb <- aa[order(aa$b, aa$b),]   #as a entire to order, first to order by the first and then order by the second  
order <- data_state[order(data_state[,11], data_state[,2], na.last = NA), ]
#sort
> sort(aa$b)
[1]   1  20  21  23 444
#rank 
> rank(aa$b)
#arrange 
 require(plyr)
order_selected <- arrange(selected_state, selected_state[,outcome], Hospital.Name, na.last=TRUE)
  same:  order <- data_state[order(data_state[,11], data_state[,2], na.last = NA), ]

#clear 
!!! every time try a new sample, clear the environment first. 
[1] 3 4 5 1 2



5. Detection 
# T& F
 if (!outcome %in% c( "heart attack","heart failure","pneumonia")){
 aa <- "invaid outcome"
  if (!state %in% unique(rates$State))
 return("Invalid State")
 
 
 6. multiple function 
 #*apply 
dim(flags)
[1] 194  30    # 194 rows, and 30 columns
mortality_rates[,c(3,4,5)] <- apply(mortality_rates[,3:5],2,as.numeric)
sapply(flag_shapes, range)  # the min and max value of each column
sapply(flags, unique) # returns a list containing one vector of unique values for each column of the flags dataset
vapply(flags, unique, numeric(1))  #  a safer than sapply : error if each element of the result to be NOT a numeric vector of length 1
table(flags$landmass)
 1  2  3  4  5  6 
31 17 35 52 39 20     # the number of every level 
tapply(flags$animate, flags$landmass, mean)    
  1         2         3         4         5         6 
0.4193548 0.1764706 0.1142857 0.1346154 0.1538462 0.3000000     #to apply the mean function to the 'animate' variable separately
                                                                for each of the six landmass groups. split your data
                                                                into groups based on the value of some variable, then apply a
                                                                function to each group.                                                                
tapply(mtcars$mpg, mtcars$cyl, mean) == sapply(split(mtcars$mpg, mtcars$cyl), mean) == with(mtcars, tapply(mpg, cyl, mean))                                                                 

7. other 
min <- .Machine$integer.max

